namespace SignalFx.Tracing.DogStatsd
{
    internal static class TracerMetricNames
    {
        public static class Api
        {
            /// <summary>
            /// Count: Total number of API requests made
            /// </summary>
            public const string Requests = "signalfx.tracing.api.requests";

            /// <summary>
            /// Count: Count of API responses.
            /// This metric has an additional tag of "status: {code}" to group the responses by the HTTP response code.
            /// This is different from <seealso cref="Errors"/> in that this is all HTTP responses
            /// regardless of status code, and <seealso cref="Errors"/> is exceptions raised from making an API call.
            /// </summary>
            public const string Responses = "signalfx.tracing.api.responses";

            /// <summary>
            /// Count: Total number of exceptions raised by API calls.
            /// This is different from receiving a 4xx or 5xx response.
            /// It is a "timeout error" or something from making the API call.
            /// </summary>
            public const string Errors = "signalfx.tracing.api.errors";
        }

        public static class Queue
        {
            /// <summary>
            /// Count: Total number of traces pushed into the queue (does not include traces dropped due to a full queue)
            /// </summary>
            public const string EnqueuedTraces = "signalfx.tracing.queue.enqueued_traces";

            /// <summary>
            /// Count: Total number of spans pushed into the queue (does not include traces dropped due to a full queue)
            /// </summary>
            public const string EnqueuedSpans = "signalfx.tracing.queue.enqueued_spans";

            /// <summary>
            /// Count: Total size in bytes of traces pushed into the queue (does not include traces dropped due to a full queue)
            /// </summary>
            public const string EnqueuedBytes = "signalfx.tracing.queue.enqueued_bytes";

            /// <summary>
            /// Count: Total number of traces dropped due to a full queue
            /// </summary>
            public const string DroppedTraces = "signalfx.tracing.queue.dropped_traces";

            /// <summary>
            /// Count: Total number of spans dropped due to a full queue
            /// </summary>
            public const string DroppedSpans = "signalfx.tracing.queue.dropped_spans";

            /// <summary>
            /// Count: Number of traces pulled from the queue for flushing
            /// </summary>
            public const string DequeuedTraces = "signalfx.tracing.queue.dequeued_traces";

            /// <summary>
            /// Count: Total number of spans pulled from the queue for flushing
            /// </summary>
            public const string DequeuedSpans = "signalfx.tracing.queue.dequeued_spans";

            /// <summary>
            /// Count: Size in bytes of traces pulled from the queue for flushing
            /// </summary>
            public const string DequeuedBytes = "signalfx.tracing.queue.dequeued_bytes";

            /// <summary>
            /// Gauge: The maximum number of traces buffered by the background writer (this is static at 1k for now)
            /// </summary>
            public const string MaxTraces = "signalfx.tracing.queue.max_traces";
        }

        public static class Health
        {
            /// <summary>
            /// Gauge: Set to 1 by each Tracer instance.
            /// </summary>
            public const string Heartbeat = "signalfx.tracing.heartbeat";

            /// <summary>
            /// Count: The number of exceptions thrown by the Tracer.
            /// </summary>
            public const string Exceptions = "signalfx.tracing.health.exceptions";

            /// <summary>
            /// Count: The number of warnings generated by the Tracer.
            /// </summary>
            public const string Warnings = "signalfx.tracing.health.warnings";
        }
    }
}
